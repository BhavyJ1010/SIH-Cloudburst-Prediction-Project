import time
import json
import random
import logging
import argparse
import threading
import os
from datetime import datetime, timezone, timedelta
import csv

# ------------------------
# Logging
# ------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

# ------------------------
# Time helpers
# ------------------------
try:
    from zoneinfo import ZoneInfo
    IST = ZoneInfo("Asia/Kolkata")
except Exception:
    IST = None
    logging.warning("ZoneInfo not available; using system time")

def now_utc():
    return datetime.now(timezone.utc)

def now_local_for_csv():
    if IST is not None:
        dt = datetime.now(IST)
    else:
        dt = datetime.now()
    return dt.strftime("%d-%m-%Y %H:%M")

# ------------------------
# Config / CSV
# ------------------------
REALTIME_CSV_PATH = "realtime_features.csv"
LOCATION_ID = "loc_1"
RAIN_GAUGE_MM_PER_TIP = 0.2794  # mm per tip
ANEMO_PULSES_TO_KMPH = 2.4

FINAL_CSV_COLUMNS = [
    "timestamp",
    "location_id",
    "rainfall_mm",
    "humidity",
    "pressure",
    "temperature",
    "wind_gust",
    "satellite_precip",
    "radar_dbz",
    "cloudburst",
    "rain_last_5min",
    "rain_last_15min",
    "pressure_drop_15min",
    "humidity_change",
    "forecast_30min",
]

# ------------------------
# Tipping bucket + anemometer (memory only)
# ------------------------
RAIN_LOCK = threading.Lock()
RAIN_TIPS = 0

WIND_PULSE_LOCK = threading.Lock()
WIND_PULSE_COUNT = 0

def rain_gauge_callback():
    global RAIN_TIPS
    with RAIN_LOCK:
        RAIN_TIPS += 1

def get_and_reset_rain_tips():
    global RAIN_TIPS
    with RAIN_LOCK:
        tips = RAIN_TIPS
        RAIN_TIPS = 0
    return tips

def anemometer_callback():
    global WIND_PULSE_COUNT
    with WIND_PULSE_LOCK:
        WIND_PULSE_COUNT += 1

def get_and_reset_wind_pulses():
    global WIND_PULSE_COUNT
    with WIND_PULSE_LOCK:
        pulses = WIND_PULSE_COUNT
        WIND_PULSE_COUNT = 0
    return pulses

# ------------------------
# Simulated sensors
# ------------------------
def read_sht_temp_humidity():
    temperature = round(25 + random.uniform(-3, 3), 2)
    humidity = round(60 + random.uniform(-15, 15), 2)
    return temperature, humidity

def read_bme280_pressure():
    return round(1010 + random.uniform(-10, 10), 3)

def read_anemometer(interval_s: int, simulate=False):
    if simulate:
        return round(random.uniform(0, 30), 3)
    pulses = get_and_reset_wind_pulses()
    pulses_per_sec = pulses / float(interval_s) if interval_s > 0 else 0
    return round(pulses_per_sec * ANEMO_PULSES_TO_KMPH, 3)

# ------------------------
# Sanitizers
# ------------------------
def sanitize_temperature(t):
    return t if -40 <= t <= 85 else None

def sanitize_humidity(h):
    return h if 0 <= h <= 100 else None

def sanitize_pressure(p):
    return p if 800 <= p <= 1100 else None

# ------------------------
# Historical placeholder (CSV-only → no DB history)
# ------------------------
def get_rain_total_since(minutes: int):
    """No database → no history → return 0."""
    return 0.0

# ------------------------
# Build feature row
# ------------------------
def build_realtime_features(interval_s: int, simulate=False):
    ts_csv = now_local_for_csv()

    temperature, humidity = read_sht_temp_humidity()
    pressure = read_bme280_pressure()
    rainfall_mm = get_and_reset_rain_tips() * RAIN_GAUGE_MM_PER_TIP
    wind_gust = read_anemometer(interval_s, simulate)

    temperature = sanitize_temperature(temperature) or 0
    humidity = sanitize_humidity(humidity) or 0
    pressure = sanitize_pressure(pressure) or 0

    rain_last_5 = get_rain_total_since(5) + rainfall_mm
    rain_last_15 = get_rain_total_since(15) + rainfall_mm

    pressure_drop_15min = 0.0
    humidity_change = 0.0

    row = {
        "timestamp": ts_csv,
        "location_id": LOCATION_ID,
        "rainfall_mm": rainfall_mm,
        "humidity": humidity,
        "pressure": pressure,
        "temperature": temperature,
        "wind_gust": wind_gust,
        "satellite_precip": 0.0,
        "radar_dbz": 0.0,
        "cloudburst": 0,
        "rain_last_5min": rain_last_5,
        "rain_last_15min": rain_last_15,
        "pressure_drop_15min": pressure_drop_15min,
        "humidity_change": humidity_change,
        "forecast_30min": 0.0,
    }
    return row

# ------------------------
# CSV logging
# ------------------------
def append_to_realtime_csv(row):
    file_exists = os.path.exists(REALTIME_CSV_PATH)
    with open(REALTIME_CSV_PATH, "a", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=FINAL_CSV_COLUMNS)
        if not file_exists:
            writer.writeheader()
        writer.writerow(row)
    logging.info("CSV row written: %s", row)

# ------------------------
# Main loop
# ------------------------
def main_loop(simulate=False, interval=60):
    try:
        while True:
            if simulate:
                for _ in range(random.randint(0, 3)):
                    if random.random() < 0.4:
                        rain_gauge_callback()

            row = build_realtime_features(interval, simulate)
            append_to_realtime_csv(row)
            logging.info("Saved row: %s", json.dumps(row))

            time.sleep(1 if simulate else interval)
    except KeyboardInterrupt:
        logging.info("Stopping loop…")

# ------------------------
# Run-once mode
# ------------------------
def run_once(simulate=False, interval=60):
    if simulate:
        for _ in range(6):
            if random.random() < 0.4:
                rain_gauge_callback()
            time.sleep(0.05)

    row = build_realtime_features(interval, simulate)
    append_to_realtime_csv(row)
    print(json.dumps(row, indent=2))

# ------------------------
# CLI
# ------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--simulate", action="store_true")
    parser.add_argument("--interval", type=int, default=60)
    parser.add_argument("--once", action="store_true")
    args = parser.parse_args()

    if args.once:
        run_once(simulate=args.simulate, interval=args.interval)
    else:
        main_loop(simulate=args.simulate, interval=args.interval)
