#!/usr/bin/env python3
"""
Robust ML prediction script that:
- works without a DB (in-memory / filesystem optional)
- auto-detects hardware (Raspberry Pi) and falls back to simulated sensors otherwise
- safely loads or trains models, with synthetic-data fallback when training data is tiny/missing
- optional persistence of trained models (MODEL_SAVE)
"""

import os
import json
import joblib
import random
import numpy as np
import pandas as pd
from datetime import datetime

# ML libs
import lightgbm as lgbm
from sklearn.ensemble import IsolationForest
from sklearn.linear_model import LinearRegression
from sklearn.utils import resample

# Try hardware-specific imports; if they fail we switch to simulation
HAVE_RPI = True
try:
    import board
    import busio
    import RPi.GPIO as GPIO
    from adafruit_bme280 import basic as adafruit_bme280
except Exception:
    HAVE_RPI = False

# ----------------------------
# Config
# ----------------------------
MODEL_FILES = {
    "anomaly": 'anomaly_detector_if.pkl',
    "multi_class": 'weather_classifier_lgbm.pkl',
    "forecaster": 'temp_forecaster_lr.pkl'
}

# Change to False if you don't want the script to write model files
MODEL_SAVE = True

WEATHER_CLASSES = {0: "Sunny", 1: "Cloudy", 2: "Light Rain", 3: "Heavy Rain"}
FEATURES = ["Temp", "Humidity", "Pressure"]
RANDOM_STATE = 42

# Hardware pins (only used when HAVE_RPI True)
RAIN_GAUGE_PIN = 17
OPTICAL_RAIN_PIN = 27
RAIN_GAUGE_MM_PER_TIP = 0.2794

# ----------------------------
# Sensor abstraction (real vs simulated)
# ----------------------------
class SensorReader:
    def __init__(self):
        self.use_real = HAVE_RPI
        self.rain_tips = 0

        if self.use_real:
            try:
                GPIO.setmode(GPIO.BCM)
                GPIO.setup(RAIN_GAUGE_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
                GPIO.setup(OPTICAL_RAIN_PIN, GPIO.IN)

                # attach ISR
                GPIO.add_event_detect(
                    RAIN_GAUGE_PIN,
                    GPIO.FALLING,
                    callback=self._rain_tip_callback,
                    bouncetime=300
                )

                # BME280 setup
                i2c = busio.I2C(board.SCL, board.SDA)
                self.bme280 = adafruit_bme280.Adafruit_BME280_I2C(i2c)
            except Exception:
                # fallback to simulation if any hardware init fails
                self.use_real = False

    def _rain_tip_callback(self, channel):
        self.rain_tips += 1

    def read(self):
        """Return dict with keys matching ML FEATURES (Temp, Humidity, Pressure)
           plus Rain_mm and Optical_Dry."""
        if self.use_real:
            try:
                temperature = round(self.bme280.temperature, 2)
                humidity = round(self.bme280.humidity, 2)
                pressure = round(self.bme280.pressure, 2)
                optical_is_dry = GPIO.input(OPTICAL_RAIN_PIN)
                rain_mm = round(self.rain_tips * RAIN_GAUGE_MM_PER_TIP, 3)
                return {
                    "Temp": temperature,
                    "Humidity": humidity,
                    "Pressure": pressure,
                    "Rain_mm": rain_mm,
                    "Optical_Dry": int(optical_is_dry)
                }
            except Exception:
                # degrade to simulated reading if sensor read fails
                self.use_real = False

        # Simulated reading
        temperature = round(20 + random.uniform(-5, 8), 2)
        humidity = round(55 + random.uniform(-25, 25), 2)
        pressure = round(1010 + random.uniform(-15, 15), 2)
        # simulate occasional rain tips
        if random.random() < 0.25:
            self.rain_tips += random.randint(1, 4)
        optical_is_dry = 1 if random.random() > 0.15 else 0
        rain_mm = round(self.rain_tips * RAIN_GAUGE_MM_PER_TIP, 3)
        return {
            "Temp": temperature,
            "Humidity": humidity,
            "Pressure": pressure,
            "Rain_mm": rain_mm,
            "Optical_Dry": int(optical_is_dry)
        }

    def cleanup(self):
        if HAVE_RPI and self.use_real:
            try:
                GPIO.cleanup()
            except Exception:
                pass

# ----------------------------
# Training data (may be empty or tiny in user scenario)
# ----------------------------
# NOTE: you said "without predefined data" â€” still keep a tiny seed set
# to allow bootstrapping; we'll generate more synthetic samples if not enough.
SEED_RAW_DATA = [
    [25.0, 75.0, 1005.0, 2],
    [15.2, 85.1, 1000.5, 3],
    [30.5, 45.0, 1018.0, 0],
    [20.1, 60.5, 1012.3, 1],
    [22.8, 70.0, 1008.1, 2],
    [10.0, 95.0, 998.0, 3],
    [28.9, 50.2, 1020.5, 0],
]
RAW_DATA = SEED_RAW_DATA.copy()  # can be [] to simulate no data

# ----------------------------
# Utilities: safe load or train
# ----------------------------
def ensure_training_df(raw_data, min_rows=50):
    """Return a DataFrame with at least min_rows rows; if insufficient,
       create synthetic variations (bootstrapping + noise)."""
    if not raw_data:
        # create small initial balanced dataset using plausible ranges
        raw_data = [
            [random.uniform(28, 35), random.uniform(30, 60), random.uniform(1010, 1025), 0],  # Sunny
            [random.uniform(18, 25), random.uniform(50, 75), random.uniform(1005, 1015), 1],  # Cloudy
            [random.uniform(18, 25), random.uniform(70, 95), random.uniform(1000, 1010), 2],  # Light Rain
            [random.uniform(5, 18), random.uniform(80, 100), random.uniform(990, 1005), 3],   # Heavy Rain
        ] * 3
    df = pd.DataFrame(raw_data, columns=FEATURES + ["Weather_Label"])
    if len(df) >= min_rows:
        return df
    # bootstrap/resample with Gaussian noise to reach min_rows
    rows = []
    rng = np.random.RandomState(RANDOM_STATE)
    while len(rows) + len(df) < min_rows:
        sample = df.sample(n=min(5, len(df)), replace=True, random_state=rng.randint(0, 1_000_000))
        for _, r in sample.iterrows():
            noisy = r[FEATURES].astype(float).values + rng.normal(scale=[0.8, 3.0, 2.0], size=3)
            rows.append([float(noisy[0]), float(noisy[1]), float(noisy[2]), int(r["Weather_Label"])])
    df_aug = pd.concat([df, pd.DataFrame(rows, columns=FEATURES + ["Weather_Label"])], ignore_index=True)
    return df_aug

def safe_joblib_load(fname):
    try:
        return joblib.load(fname)
    except Exception:
        return None

def load_or_train(model_type, train_func, raw_data=RAW_DATA):
    fname = MODEL_FILES.get(model_type)
    # try load
    if fname and os.path.exists(fname):
        loaded = safe_joblib_load(fname)
        if loaded is not None:
            return loaded
    # need to train
    df = ensure_training_df(raw_data, min_rows=60)
    model = train_func(df)
    if MODEL_SAVE and fname:
        try:
            joblib.dump(model, fname)
        except Exception:
            pass
    return model

# ----------------------------
# Models: train functions
# ----------------------------
def train_multi_class(df):
    X = df[FEATURES].astype(float)
    y = df["Weather_Label"].astype(int)
    model = lgbm.LGBMClassifier(objective="multiclass", num_class=len(WEATHER_CLASSES), n_estimators=80, random_state=RANDOM_STATE)
    model.fit(X, y)
    return model

def predict_weather(model, sensor_data):
    arr = np.array([sensor_data[f] for f in FEATURES]).reshape(1, -1)
    pred_class = int(model.predict(arr)[0])
    confidence = None
    # many classifiers have predict_proba; guard if not present
    if hasattr(model, "predict_proba"):
        try:
            probs = model.predict_proba(arr)[0]
            confidence = round(float(probs[pred_class]) * 100, 2)
        except Exception:
            confidence = None
    return {
        "predicted_class_id": pred_class,
        "predicted_state": WEATHER_CLASSES.get(pred_class, str(pred_class)),
        "confidence_percent": confidence
    }

def train_isolation_forest(df):
    X = df[FEATURES].astype(float)
    model = IsolationForest(contamination=0.05, random_state=RANDOM_STATE)
    model.fit(X)
    return model

def predict_anomaly(model, sensor_data):
    arr = np.array([sensor_data[f] for f in FEATURES]).reshape(1, -1)
    out = int(model.predict(arr)[0])
    score = float(model.decision_function(arr)[0])
    return {
        "is_anomaly": (out == -1),
        "anomaly_score": round(score, 4)
    }

def train_forecaster(df):
    temps = df["Temp"].astype(float).values
    # if not enough samples, create a simple autoregressive training set
    X, y = [], []
    window = 3
    for i in range(len(temps) - window):
        X.append(temps[i:i + window])
        y.append(temps[i + window])
    if not X:
        # fallback: create dummy linear model from simple trend
        model = LinearRegression()
        model.coef_ = np.zeros((1, window))
        model.intercept_ = float(np.mean(temps)) if len(temps) > 0 else 20.0
        # This dummy object won't have predict working normally; instead return a trained model below
        # So instead just train with tiny artificial dataset
        temps_series = (np.arange(0, 10) * 0.1) + 20
        X = []
        y = []
        for i in range(7):
            X.append(temps_series[i:i + window])
            y.append(temps_series[i + window])
    model = LinearRegression().fit(np.array(X), np.array(y))
    return model

def predict_temp(model, last3):
    arr = np.array(last3).reshape(1, -1)
    return float(model.predict(arr)[0])

# ----------------------------
# Main
# ----------------------------
def main():
    print("Starting robust ML prediction (no DB required).")
    sr = SensorReader()
    try:
        # load/train models
        print("Loading or training models...")
        model_cls = load_or_train("multi_class", train_multi_class)
        model_anom = load_or_train("anomaly", train_isolation_forest)
        model_temp = load_or_train("forecaster", train_forecaster)

        # read sensors
        sensor_data = sr.read()
        # Ensure sensor_data has FEATURE keys
        input_for_ml = {k: sensor_data[k] for k in FEATURES}

        print("\nSensor Data:")
        print(json.dumps(sensor_data, indent=2))

        # ML predictions
        weather_state = predict_weather(model_cls, input_for_ml)
        anomaly_status = predict_anomaly(model_anom, input_for_ml)

        # Last-3 temps: if you don't have history, use synthetic shift
        last3 = [input_for_ml["Temp"] - 0.3, input_for_ml["Temp"] - 0.1, input_for_ml["Temp"]]
        next_temp = predict_temp(model_temp, last3)

        result = {
            "sensor_data": sensor_data,
            "weather_state": weather_state,
            "anomaly": anomaly_status,
            "forecast_temp_next": round(float(next_temp), 2),
            "timestamp": datetime.utcnow().isoformat()
        }

        print("\n=== ML OUTPUT ===")
        print(json.dumps(result, indent=4))

    finally:
        sr.cleanup()

if __name__ == "__main__":
    main()
